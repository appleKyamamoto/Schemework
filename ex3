(define ** expt)
(define diff
  (lambda (f)
    (cond ( (number? f)
            '0 )
          ( (eqv? 'x f)
            '1 )
          ( (eqv? '+ (car f))
            (cons '+ (map diff (cdr f))) )
          ( (eqv? '- (car f))
            (cons '- (map diff (cdr f))) )
          ( (eqv? '* (car f))
            `(+ (* ,(cadr f) ,(diff (caddr f)) ) (* ,(diff (cadr f)) ,(caddr f) )) )
          ( (eqv? '** (car f))
            `(* ,(caddr f) (* ,(diff (cadr f)) (** ,(cadr f) ,(- (caddr f) 1) ))) )
          ( else '() )
          )))

(define tangent
  (lambda (fx x)
    (let ((fdx (diff fx) ))
      (let ( (evd ((eval `(lambda (x) ,fdx) (interaction-environment)) x)) )
      `(+ (* ,evd x ) ,(+ ((eval `(lambda (x) ,fx) (interaction-environment)) x) (* evd (- x))))
        ))
    ))

(define diff2
  (lambda (f d)
    (let ((diffw (lambda (ft) (diff2 ft d))))
      (cond ( (or (number? f) (and (eqv? 'x f) (eqv? 'y d)) (and (eqv? 'y f) (eqv? 'x d)))
              '0 )
            ( (or (and (eqv? 'x f) (eqv? 'x d)) (and (eqv? 'y f) (eqv? 'y d)))
              '1 )
            ( (eqv? '+ (car f ))
              (cons '+ (map diffw (cdr f))) )
            ( (eqv? '- (car f))
              (cons '- (map diffw (cdr f))) )
            ( (eqv? '* (car f))
              `(+ (* ,(cadr f) ,(diffw (caddr f)) ) (* ,(diffw (cadr f)) ,(caddr f) )) )
            ( (eqv? '** (car f))
              `(* ,(caddr f) (* ,(diffw (cadr f)) (** ,(cadr f) ,(- (caddr f) 1) ))) )
            ( else '() )
            ))))

(define simple+
  (lambda (lst)
    (let ( (nzl (nzlist (make-list lst))) )
      (cond ( (null? nzl)
              '0 )
            ( (null? (cdr nzl))
              (car nzl) )
            (else (cons '+ nzl) )
            ))
  ))
(define simple-
  (lambda (lst)
    (let ( (nzl (nzlist (make-list (cdr lst)))) )
      (if (null? nzl)
          (cadr lst)
          (list '- (cadr lst) (car nzl))
          )))
  )
(define simple*
  (lambda (lst)
    (let ( (p (car lst)) (q (cadr lst)) )
      (cond ( (or (eqv? 0 p) (eqv? 0 q))
              '0 )
            ( (eqv? p 1)
              q)
            ( (eqv? q 1)
              p)
            (else (cons '* lst))
            )))
  )
(define simple**
  (lambda (lst)
    (let ( (p (car lst)) (q (cadr lst)) )
      (cond ( (eqv? q 0)
              '1 )
            ( (eqv? q 1)
              p )
            (else (cons '** lst))
            )))
  )

(define make-list
  (lambda (lst)
    (cond ( (null? lst)
            '() )
          ( (eqv? 0 (car lst))
            (cons '() (make-list (cdr lst))) )
          (else (cons `(,(car lst)) (make-list (cdr lst))) )
        )
  ))
(define nzlist
  (lambda (lst)
    (apply append lst)
    ))
(define simple
  (lambda (lst)
    (cond ( (or (number? lst) (symbol? lst)) 
            lst )
          ( (eqv? '+ (car lst))
            (simple+ (map simple (cdr lst))) )
          ( (eqv? '- (car lst))
            (simple- (map simple (cdr lst))) )
          ( (eqv? '* (car lst))
            (simple* (map simple (cdr lst))) )
          ( (eqv? '** (car lst))
            (simple** (map simple (cdr lst))) )
          (else '())
          )))